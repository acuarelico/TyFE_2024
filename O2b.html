<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Capacidad Calorífica por Partícula - O₂</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Incluir Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Incluir D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Incluir KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"></script>

    <style>
        /* (Estilos CSS permanecen iguales al código proporcionado) */
        /* Variables CSS para ajustes globales */
        :root {
            /* Tamaño del título */
            --title-font-size: 28px;
            /* Tamaño del icono */
            --icon-width: 150px;
            --icon-height: auto;
            /* Tamaño de los gráficos */
            --plot-height: 300px;
            /* Tamaño del texto en el gráfico de Cv */
            --cv-annotations-font-size: 12px;
            /* Tamaño del slider */
            --slider-thumb-size: 24px;
            --slider-track-height: 8px;
            /* Posición del botón de autoescalado */
            --auto-scale-button-position: relative;
            --auto-scale-button-top: 0;
            --auto-scale-button-right: 0;
            /* Nuevas variables para ajustar el icono */
            --icon-top: 0;
            --icon-left: 0;
        }

        /* Estilos generales */
        html, body {
            height: 100%;
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #ffffff;
            overflow-x: hidden;
        }
        /* Contenedor principal */
        #main-container {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }
        /* Contenedor del encabezado */
        #header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        h1 {
            text-align: center;
            flex: 1;
            margin: 0;
            font-size: var(--title-font-size); /* Tamaño del título */
        }
        /* Estilo para el icono */
        #icono {
            width: var(--icon-width); /* Tamaño del icono */
            height: var(--icon-height);
            margin-right: 10px;
            position: var(--icon-position, static); /* Posición del icono */
            top: var(--icon-top);
            left: var(--icon-left);
        }
        /* Contenedor de los gráficos */
        #plots {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
        }
        /* Gráficos */
        #cv-plot, #energy-levels {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
            height: var(--plot-height); /* Altura de los gráficos */
        }
        /* Sobrescribir el estilo del cursor en los elementos internos de Plotly */
        #cv-plot .cursor-crosshair,
        #cv-plot .cursor-pointer,
        #cv-plot .hoverlayer,
        #cv-plot .draglayer,
        #cv-plot .drag {
            cursor: default !important;
        }
        #cv-plot .modebar {
            display: none !important;
        }
        /* Contenedor del slider y el checkbox */
        #slider-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            position: relative; /* Para posicionar el botón de autoescalado */
        }
        /* Envoltorio del slider de temperatura */
        #temp-slider-wrapper {
            width: 60%;
            max-width: 400px;
            margin-right: 10px;
            touch-action: none;
            position: relative;
        }
        /* Slider de temperatura */
        #temp-slider {
            width: 100%;
            margin: 0;
            padding: 0;
            -webkit-appearance: none;
            appearance: none;
            height: var(--slider-track-height); /* Altura de la pista del slider */
            background: transparent;
            position: relative;
            z-index: 1;
        }
        /* Estilo de la pista del slider */
        #temp-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: var(--slider-track-height); /* Altura de la pista del slider */
            background: #ddd;
            border-radius: 4px;
        }
        #temp-slider::-moz-range-track {
            width: 100%;
            height: var(--slider-track-height);
            background: #ddd;
            border-radius: 4px;
        }
        #temp-slider::-ms-track {
            width: 100%;
            height: var(--slider-track-height);
            background: #ddd;
            border-radius: 4px;
            border: none;
            color: transparent;
        }
        /* Estilo del pulgar (thumb) del slider */
        #temp-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: var(--slider-thumb-size); /* Tamaño del pulgar del slider */
            height: var(--slider-thumb-size);
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            margin-top: calc(-0.5 * var(--slider-thumb-size) + 0.5 * var(--slider-track-height));
        }
        #temp-slider::-moz-range-thumb {
            width: var(--slider-thumb-size);
            height: var(--slider-thumb-size);
            background: #4CAF50;
            border: none;
            border-radius: 50%;
            cursor: pointer;
        }
        #temp-slider::-ms-thumb {
            width: var(--slider-thumb-size);
            height: var(--slider-thumb-size);
            background: #4CAF50;
            border: none;
            border-radius: 50%;
            cursor: pointer;
        }
        /* Contenedor del checkbox de autoescalado */
        #auto-scale-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
            position: var(--auto-scale-button-position); /* Posición del botón de autoescalado */
            top: var(--auto-scale-button-top);
            right: var(--auto-scale-button-right);
        }
        #auto-scale-checkbox {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            border: 2px solid #4CAF50;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
            margin-right: 10px;
        }
        #auto-scale-checkbox:checked {
            background-color: #4CAF50;
        }
        #auto-scale-checkbox:checked::before {
            content: '\2714';
            display: block;
            text-align: center;
            color: white;
            font-size: 20px;
            line-height: 30px;
        }
        label[for="auto-scale-checkbox"] {
            font-size: 18px;
            cursor: pointer;
        }
        /* Texto de temperatura actual */
        #temp-value {
            font-size: 18px;
            text-align: center;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        /* Partículas */
        .particle {
            pointer-events: none;
        }
        /* Estilo para el contenedor de la explicación */
        #collapsible-text-container {
            width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
            overflow-y: visible;
            margin: 50px auto 0 auto;
            font-size: 14px;
            max-width: 800px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        #collapsible-text-container h2 {
            margin-bottom: 20px;
            font-size: 20px;
        }
        #collapsible-text-container p, 
        #collapsible-text-container h3, 
        #collapsible-text-container h4, 
        #collapsible-text-container ul, 
        #collapsible-text-container ol {
            margin: 20px 0px 0px 0px;
        }
        /* Ajustes para fórmulas matemáticas en dispositivos móviles */
        #collapsible-text-container .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
        }
        /* Estilo para el texto de E_max */
        .e-max-label {
            font-size: 12px;
            font-family: monospace;
        }
        /* Estilo para la flecha */
        .e-max-arrow {
            stroke: gray;
            fill: gray;
        }
        /* Ajustes para dispositivos móviles */
        @media (max-width: 600px) {
            /* Variables CSS para ajustes en móviles */
            :root {
                --title-font-size: 12px;
                --icon-width: 70px;
                --icon-height: auto;
                --icon-top-mobile: -10px;
                --icon-left-mobile: 0px;
                --plot-height: 200px;
                --cv-annotations-font-size: 10px;
                --slider-thumb-size: 20px;
                --slider-track-height: 10px;
                --auto-scale-button-top: 15px;
            }
            body {
                font-size: 12px;
                padding: 10px 5px 5px 5px;
            }
            h1 {
                font-size: var(--title-font-size);
                line-height: 1.2;
            }
            #header {
                flex-direction: row;
                align-items: center;
                justify-content: flex-start;
            }
            #main-container {
                margin-top: 20px;
            }
            #icono {
                margin-right: 10px;
                margin-bottom: 0;
                width: var(--icon-width);
                height: var(--icon-height-mobile);
                position: absolute;
                top: var(--icon-top-mobile);
                left: var(--icon-left-mobile);
            }
            #collapsible-text-container {
                width: 100%;
                margin: 20px 0px 0px 0px;
            }
            #cv-plot, #energy-levels {
                height: var(--plot-height);
                width: 100%;
                margin-bottom: 5px;
            }
            #slider-container {
                flex-direction: column;
                align-items: center;
            }
            #temp-slider-wrapper {
                width: 80%;
                margin-right: 5px;
                margin-left: 35px;
                margin-bottom: 0px;
            }
            #auto-scale-container {
                margin-top: var(--auto-scale-button-top);
            }
            #auto-scale-checkbox {
                width: 20px;
                height: 20px;
            }
            #auto-scale-checkbox:checked::before {
                font-size: 18px;
                line-height: 18px;
            }
            label[for="auto-scale-checkbox"] {
                font-size: 14px;
            }
            #collapsible-text-container h2 {
                font-size: 16px;
                margin-bottom: 10px;
            }
            #collapsible-text-container p, 
            #collapsible-text-container h3, 
            #collapsible-text-container h4, 
            #collapsible-text-container ul, 
            #collapsible-text-container ol {
                margin: 10px 0px 0px 0px;       
            }
            #temp-value {
                font-size: 14px;
            }
            /* Reducir el tamaño de los textos en el gráfico superior */
            #cv-plot .ytick text,
            #cv-plot .xtick text {
                font-size: var(--cv-annotations-font-size) !important;
            }
        }
    </style>
</head>
<body>
    <!-- Contenedor principal -->
    <div id="main-container">
        <!-- Contenedor del encabezado -->
        <div id="header">
            <!-- Icono a la izquierda del título -->
            <img src="iconourjc.png" alt="Icono" id="icono">
            <h1>Capacidad Calorífica por Partícula - O₂</h1>
        </div>
        <!-- Texto de temperatura actual -->
        <div id="temp-value">T = 0.001 K</div>
        <!-- Contenedor de los gráficos -->
        <div id="plots">
            <div id="cv-plot"></div>
            <div id="energy-levels"></div>
        </div>
        <!-- Contenedor del slider y el checkbox -->
        <div id="slider-container">
            <div id="temp-slider-wrapper">
                <input type="range" id="temp-slider" min="-3" max="4" step="0.01" value="-3">
            </div>
            <div id="auto-scale-container">
                <input type="checkbox" id="auto-scale-checkbox" checked>
                <label for="auto-scale-checkbox">Autoescalado</label>
            </div>
        </div>
        <!-- Contenedor de la explicación siempre visible -->
        <div id="collapsible-text-container">
            <!-- Agregar título de explicación -->
            <h2>Explicación:</h2>
    <div id="collapsible-text">
                <!-- Contenido de la explicación -->
                <p>
                    Esta simulación computa la capacidad calorífica por partícula (\(C_V\)) de una molécula diatómica de O₂ en función de la temperatura (T), demostrando la transición desde el comportamiento cuántico al clásico. La interacción con la simulación se realiza con el slider de temperatura y el botón de autoescalado que ajusta la escala de visualización. Ver limitaciones de este modelo al final del texto.
                </p>
                <h3>• Gráfico superior</h3>
                <p>
                    Muestra \(C_V = \left(\frac{\partial \langle E \rangle}{\partial T}\right)_V\) en función de T, siendo \(\langle E \rangle\) la energía media de la partícula. Las líneas horizontales discontinuas representan los límites clásicos de \(C_V\) para diferentes grados de libertad activos.     
                </p>
                <h4>Comportamiento con la temperatura</h4>
                <p>
                    <strong>Bajas temperaturas:</strong> Solo los niveles traslacionales más bajos son accesibles debido a su menor separación energética. \(C_V\) es bajo ya que solo estos niveles pueden almacenar energía.
                </p>
                <p>
                    <strong>Temperaturas intermedias:</strong> Los niveles rotacionales se vuelven accesibles, aumentando \(C_V\) ya que más estados pueden almacenar energía con el mismo incremento de T.
                </p>
                <p>
                    <strong>Altas temperaturas:</strong> Los niveles vibracionales se activan, llevando \(C_V\) a su valor máximo cuando todos los grados de libertad están completamente disponibles para almacenar energía.
                </p>
                <h4>Límites clásicos</h4>
                <p>
                    A altas temperaturas, \(C_V\) se aproxima a los límites clásicos:
                </p>
                <ul>
                    <li>\(\frac{3}{2} k_B\): Solo traslación activa</li>
                    <li>\(\frac{5}{2} k_B\): Traslación y rotación activas</li>
                    <li>\(\frac{7}{2} k_B\): Traslación, rotación y vibración activas</li>
                </ul>
                <p>
                    Donde \(k_B = 1.380649 \times 10^{-23}\) J/K es la constante de Boltzmann.
                </p>
                
                <h3>• Gráfico inferior</h3>
                <p>
                    Visualiza los niveles cuánticos de energía traslacional, rotacional y vibracional. Las partículas se distribuyen en estos niveles según la probabilidad de ocupación dada por el factor de Boltzmann, \(e^{-E/k_BT}\).
                </p>
                
                <p>
                    El <strong>botón de autoescalado</strong> ajusta dinámicamente la escala de visualización de los niveles de energía:
                </p>
                <ul>
                    <li>Activado: La escala de visualización se ajusta dinámicamente con la temperatura, manteniendo visible la línea \(k_BT\).</li>
                    <li>Desactivado: La escala se fija (se congela la visualización de los niveles), permitiendo observar cómo los niveles de energía se llenan a medida que aumenta la temperatura.</li>
                </ul>
                
                <h3>• Niveles de energía</h3>
                <p>Los niveles de energía para cada modo se calculan como sigue:</p>
                <ul>
                    <li>Traslacional( x3): \(E_n = \frac{n^2h^2}{8mL^2}\)
<br><br>
\(n\) = número cuántico (\(n \geq 1\), entero)
<br>\(h\) = constante de Planck
<br>\(m = 5.3137245312 \times 10^{-26}\) kg (masa de O₂)
<br>\(L = 4 \times 10^{-9}\) m (longitud de la caja)
</li>
                    <br>
                    <li>Rotacional: \(E_J = \frac{J(J+1)\hbar^2}{2I}\)
                    <br><br>
                    \(J\) = número cuántico rotacional (\(J \geq 0\), entero)
                    <br>\(\hbar = \frac{h}{2\pi}\) (constante de Planck reducida)
                    <br>\(I = 1.9 \times 10^{-46}\) kg·m² (momento de inercia de O₂)
                    </li>
                    <br>
                    <li>Vibracional: \(E_l = \left(l + \frac{1}{2}\right)\hbar\omega\)
                    <br><br>
                    \(l\) = número cuántico vibracional (\(l \geq 0\), entero)
                    <br>\(\hbar = \frac{h}{2\pi}\) (constante de Planck reducida)
                    <br>\(\omega = 2.97 \times 10^{14}\) rad/s (frecuencia angular del oscilador)
                    </li>
                </ul>
               
                <p style="font-size: 0.9em;"><strong>Nota sobre el cálculo de \(C_V\):</strong> En esta simulación, \(C_V\) se calcula como la derivada de la energía respecto a la temperatura, que es equivalente a la fórmula de fluctuaciones:</p>
                
                <p style="font-size: 0.9em;">\[C_V = \left(\frac{\partial \langle E \rangle}{\partial T}\right)_V = \frac{1}{k_BT^2} \left(\langle E^2 \rangle - \langle E \rangle^2\right)\]</p>
                
                <p style="font-size: 0.9em;">Donde:</p>
                <p style="font-size: 0.7em;">
    \[\langle E \rangle = \frac{\sum_i E_i \exp\left(-\frac{E_i}{k_BT}\right)}{\sum_i \exp\left(-\frac{E_i}{k_BT}\right)} \quad \quad \langle E^2 \rangle = \frac{\sum_i E_i^2 \exp\left(-\frac{E_i}{k_BT}\right)}{\sum_i \exp\left(-\frac{E_i}{k_BT}\right)}\]
</p>
                
                <p style="font-size: 0.9em;">Donde \(E_i\) son los niveles de energía para cada modo, y la suma se realiza sobre todos los niveles considerados (cuantos más, mejor).</p>
                <ul style="font-size: 0.9em;">
                    <li>Traslacional (\(E_n = \frac{n^2h^2}{8mL^2}\)) : 4500 niveles (n = 1 a 4500)</li>
                    <li>Rotacional (\(E_J = \frac{J(J+1)\hbar^2}{2I}\)) : 1001 niveles (J = 0 a 1000)</li>
                    <li>Vibracional (\(E_l = \left(l + \frac{1}{2}\right)\hbar\omega\)) : 501 niveles (l = 0 a 500)</li>
                </ul>
                <p style="font-size: 0.9em;">Para tener en cuenta las 3 dimensiones del movimiento traslacional, el \(E_n\) traslacional se multiplicó por 3 en los cálculos de \(C_V\).</p>

<p style="font-size: 0.9em;"><strong> Limitaciones del modelo:</strong>
<div style="font-size: 0.9em;">
    <p>Este modelo, aunque útil para comprender el comportamiento general de la capacidad calorífica de moléculas diatómicas, tiene varias limitaciones importantes:</p>
    <ul>
        
<li><strong>Gas ideal a baja presión:</strong> Se asume un gas a baja presión en un volumen fijo, lo cual puede no ser representativo de todas las condiciones experimentales.</li>
        
<li><strong>Fase gaseosa constante:</strong> Se supone que la molécula se mantiene en fase gaseosa en todo el rango de temperaturas.</li>
       
 <li><strong>No disociación:</strong> El modelo no considera la posibilidad de disociación molecular a altas temperaturas donde la molécula diatómica se rompería.</li>
        
<li><strong>Independencia de niveles energéticos:</strong> Se asume que los niveles energéticos (traslacional, rotacional y vibracional) son independientes entre sí. Esta aproximación es menos precisa a altas temperaturas, donde puede haber un acoplamiento significativo entre estos modos.</li>
 <li><strong>Número fijo de niveles:</strong> Se utiliza un número fijo de niveles energéticos para cada modo, lo cual es una aproximación. En realidad el número de niveles accesibles aumenta con la temperatura.</li>
        
<li><strong>Simplificación de niveles traslacionales:</strong> Se utiliza una aproximación unidimensional (la que se visualiza) \(E_n = \frac{n^2h^2}{8mL^2}\), en lugar del cálculo 3D completo (\(E_{n_x,n_y,n_z} = \frac{h^2}{8mL^2}(n_x^2 + n_y^2 + n_z^2)\)). Esto reduce significativamente el costo computacional al generar menos niveles de energía (del orden de N en lugar de N³), y mejora la visualización al disminuir la densidad de niveles en el gráfico. Para el cómputo de \(C_V\) se considera \(3E_n\) para tener en cuenta la energía de los 3 modos traslacionales. Esta aproximación puede llevar a ligeras imprecisiones en \(C_V\) a temperaturas muy bajas debido a la menor densidad de niveles. Sin embargo, con este modelo, la separación entre niveles traslacionales sigue siendo mucho menor que la de los niveles rotacionales y vibracionales, manteniendo la curva \(C_V\) prácticamente idéntica al que se obtendría con el modelo 3D completo.</li>
  
<li><strong>Rotor rígido:</strong> El tratamiento de la molécula como un rotor rígido puede requerir correcciones a altas temperaturas donde la distorsión centrífuga se vuelve significativa.</li>
    
<li><strong>Aproximación armónica:</strong> Para las vibraciones, se utiliza un modelo de oscilador armónico, que es menos preciso para niveles de energía altos. Un modelo más realista sería un oscilador anarmónico.</li>
              
<li><strong>Aproximación de Born-Oppenheimer:</strong> Esta aproximación asume que el movimiento de los electrones y los núcleos pueden tratarse por separado debido a la gran diferencia en sus masas. Permite simplificar significativamente los cálculos de estructura molecular y espectros vibracionales. Sin embargo, puede fallar en situaciones donde los estados electrónicos están muy próximos en energía o cuando hay fuertes acoplamientos vibrónico-electrónicos, como en ciertas reacciones químicas o en moléculas excitadas. En estos casos, los movimientos electrónicos y nucleares no pueden considerarse independientes, lo que puede afectar la precisión de los cálculos de energía y, por ende, la capacidad calorífica.</li>
   
   
    
          
    <p>Referencias:</p>
    <ol>
        <li>McQuarrie, D. A. (2000). Statistical Mechanics. University Science Books.</li>
        <li>Pathria, R. K., & Beale, P. D. (2011). Statistical Mechanics (3rd ed.). Academic Press.</li>
    </ol>
</div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ]
            });
        });
    </script>

    <!-- Script JavaScript Completo -->
    <script>
        // Detección de dispositivo móvil
        var isMobile = window.matchMedia("(max-width: 600px)").matches;

        // Constantes físicas para O₂
        const h = 6.62607015e-34;  // Constante de Planck
        const hBar = h / (2 * Math.PI);  // Constante de Planck reducida
        const kB = 1.380649e-23;   // Constante de Boltzmann
        const m = 32 * 1.66053906660e-27;  // Masa de O₂ (32 u)
        const L = 4e-9;            // Longitud de la caja (1 nm)
        const I = 1.9e-46;         // Momento de inercia de O₂
        const omega = 2.97e14;     // Frecuencia angular del oscilador armónico para O₂

        // Rango de temperaturas ajustado de 0.001 K a 10,000 K
        const temperatures = [];
        for (let i = -3; i <= 4; i += 0.01) {
            temperatures.push(Math.pow(10, i));
        }

        // Niveles de energía
        const n_trans_max = 4700;
        const j_rot_max = 1000;
        const n_vib_max = 500;

        // Niveles de energía traslacionales (1D)
        const En_trans = [];
        for (let n = 1; n <= n_trans_max; n++) {
            En_trans.push((n * n * h * h) / (8 * m * L * L));
        }

        // Niveles de energía rotacionales
        const En_rot = [];
        for (let J = 0; J <= j_rot_max; J++) {
            En_rot.push(J * (J + 1) * hBar * hBar / (2 * I));
        }

        // Niveles de energía vibracionales (incluyendo energía de punto cero)
        const En_vib = [];
        for (let n = 0; n <= n_vib_max; n++) {
            En_vib.push((n + 0.5) * hBar * omega); // Incluimos el 0.5
        }

        // Cálculos de energía promedio, energía cuadrática promedio y capacidad calorífica
        const E_avg_trans = [];
        const E2_avg_trans = [];

        const E_avg_rot = [];
        const E2_avg_rot = [];

        const E_avg_vib = [];
        const E2_avg_vib = [];

        const Cv_total = [];

        for (let i = 0; i < temperatures.length; i++) {
            const T = temperatures[i];
            const beta = 1 / (kB * T);

            // Translacional (1D)
            let minE_trans = En_trans[0];
            let shifted_E_trans = En_trans.map(E => E - minE_trans);
            let exp_factor_trans = shifted_E_trans.map(E => Math.exp(-beta * E));
            let Z_trans = exp_factor_trans.reduce((a, b) => a + b, 0);
            let P_trans = exp_factor_trans.map(p => p / Z_trans);

            let E_avg_t = shifted_E_trans.reduce((sum, E, index) => sum + E * P_trans[index], 0) + minE_trans;
            let E2_avg_t = shifted_E_trans.reduce((sum, E, index) => sum + (E + minE_trans) * (E + minE_trans) * P_trans[index], 0);

            E_avg_trans.push(E_avg_t);
            E2_avg_trans.push(E2_avg_t);

            // Rotacional
            let J = [...Array(j_rot_max + 1).keys()];
            let degeneracy_rot = J.map(J_value => 2 * J_value + 1);

            let minE_rot = En_rot[0];
            let shifted_E_rot = En_rot.map(E => E - minE_rot);
            let exp_factor_rot = shifted_E_rot.map((E, index) => degeneracy_rot[index] * Math.exp(-beta * E));
            let Z_rot = exp_factor_rot.reduce((a, b) => a + b, 0);
            let P_rot = exp_factor_rot.map(p => p / Z_rot);

            let E_avg_r = shifted_E_rot.reduce((sum, E, index) => sum + E * P_rot[index], 0) + minE_rot;
            let E2_avg_r = shifted_E_rot.reduce((sum, E, index) => sum + (E + minE_rot) * (E + minE_rot) * P_rot[index], 0);

            E_avg_rot.push(E_avg_r);
            E2_avg_rot.push(E2_avg_r);

            // Vibracional (1D) incluyendo energía de punto cero
            let minE_vib = En_vib[0];
            let shifted_E_vib = En_vib.map(E => E - minE_vib);
            let exp_factor_vib = shifted_E_vib.map(E => Math.exp(-beta * E));
            let Z_vib = exp_factor_vib.reduce((a, b) => a + b, 0);
            let P_vib = exp_factor_vib.map(p => p / Z_vib);

            let E_avg_v = shifted_E_vib.reduce((sum, E, index) => sum + E * P_vib[index], 0) + minE_vib;
            let E2_avg_v = shifted_E_vib.reduce((sum, E, index) => sum + (E + minE_vib) * (E + minE_vib) * P_vib[index], 0);

            E_avg_vib.push(E_avg_v);
            E2_avg_vib.push(E2_avg_v);
        }

        // Calcular Cv total usando la fórmula de fluctuaciones
        for (let i = 0; i < temperatures.length; i++) {
            const T = temperatures[i];

            // Cv translacional (3D)
            let Var_E_t = E2_avg_trans[i] - E_avg_trans[i] * E_avg_trans[i];
            let Cv_trans = (3 * Var_E_t) / (kB * T * T);

            // Cv rotacional
            let Var_E_r = E2_avg_rot[i] - E_avg_rot[i] * E_avg_rot[i];
            let Cv_rot = Var_E_r / (kB * T * T);

            // Cv vibracional
            let Var_E_v = E2_avg_vib[i] - E_avg_vib[i] * E_avg_vib[i];
            let Cv_vib = Var_E_v / (kB * T * T);

            // Cv total en unidades de kB
            let Cv_total_i = Cv_trans + Cv_rot + Cv_vib;
            Cv_total.push(Cv_total_i / kB); // Dividir por kB para tener Cv en unidades de kB
        }

        // Definir los márgenes del gráfico en función del dispositivo
        let plotMargins = isMobile ? { t: 5, l: 50, r: 30, b: 50 } : { t: 30, l: 60, r: 20, b: 50 };

        // Definir el tamaño de fuente para las anotaciones
        let annotationFontSize = isMobile ? 10 : 12;

        // Función para obtener anotaciones según dispositivo
        function getAnnotations() {
            if (isMobile) {
                return [
                    {
                        x: -0.02,
                        y: 3.5,
                        xref: 'paper',
                        yref: 'y',
                        text:'<b>7/2 K<sub>B</sub></b>',
                        showarrow: false,
                        font: { size: annotationFontSize },
                        xanchor: 'left',
                        yanchor: 'bottom'
                    },
                    {
                        x: -0.02,
                        y: 2.5,
                        xref: 'paper',
                        yref: 'y',
                        text:'<b>5/2 K<sub>B</sub></b>',
                        showarrow: false,
                        font: { size: annotationFontSize },
                        xanchor: 'left',
                        yanchor: 'bottom'
                    },
                    {
                        x: -0.02,
                        y: 1.5,
                        xref: 'paper',
                        yref: 'y',
                        text:'<b>3/2 K<sub>B</sub></b>',
                        showarrow: false,
                        font: { size: annotationFontSize },
                        xanchor: 'left',
                        yanchor: 'bottom'
                    }
                ];
            } else {
                return [
                    {
                        x: -0.02,
                        y: 3.5,
                        xref: 'paper',
                        yref: 'y',
                        text:'<b>7/2 K<sub>B</sub></b>   (T+R+V activos)',
                        showarrow: false,
                        font: { size: annotationFontSize },
                        xanchor: 'left',
                        yanchor: 'bottom'
                    },
                    {
                        x: -0.02,
                        y: 2.5,
                        xref: 'paper',
                        yref: 'y',
                        text:'<b>5/2 K<sub>B</sub></b>   (T+R activos)',
                        showarrow: false,
                        font: { size: annotationFontSize },
                        xanchor: 'left',
                        yanchor: 'bottom'
                    },
                    {
                        x: -0.02,
                        y: 1.5,
                        xref: 'paper',
                        yref: 'y',
                        text:'<b>3/2 K<sub>B</sub></b>   (T activos)',
                        showarrow: false,
                        font: { size: annotationFontSize },
                        xanchor: 'left',
                        yanchor: 'bottom'
                    }
                ];
            }
        }

        // Graficar Cv vs T
        let traceCv = {
            x: temperatures,
            y: Cv_total,
            type: 'scatter',
            mode: 'lines',
            line: { color: 'black', width: 2 },
            name: 'C<sub>V</sub>',
            hoverinfo: 'skip'
        };

        let horizontal_lines = [
            {
                type: 'line',
                x0: 0.001,
                y0: 3.5,
                x1: 1e4,
                y1: 3.5,
                line: { dash: 'dash', width: 1, color: 'gray' }
            },
            {
                type: 'line',
                x0: 0.001,
                y0: 2.5,
                x1: 1e4,
                y1: 2.5,
                line: { dash: 'dash', width: 1, color: 'gray' }
            },
            {
                type: 'line',
                x0: 0.001,
                y0: 1.5,
                x1: 1e4,
                y1: 1.5,
                line: { dash: 'dash', width: 1, color: 'gray' }
            }
        ];

        let layoutCv = {
            hovermode: false,
            dragmode: 'none',
            xaxis: {
                type: 'log',
                title: 'Temperatura (K)',
                range: [-3, 4],
                automargin: true,
                showgrid: false,
                fixedrange: true,
                tickfont: { size: 12 }
            },
            yaxis: {
                title: 'C<sub>V</sub>',
                range: [0, 4],
                automargin: true,
                showgrid: false,
                tickvals: [],
                showticklabels: false,
                fixedrange: true
            },
            margin: plotMargins,
            shapes: horizontal_lines,
            annotations: getAnnotations()
        };

        let configCv = {
            responsive: true,
            displayModeBar: false
        };

        Plotly.newPlot('cv-plot', [traceCv], layoutCv, configCv);

        // Línea vertical de temperatura actual en el gráfico de Cv
        function updateTempLine(T) {
            let update = {
                shapes: [
                    ...horizontal_lines,
                    {
                        type: 'line',
                        x0: T,
                        y0: 0,
                        x1: T,
                        y1: 4,
                        xref: 'x',
                        yref: 'y',
                        line: { color: 'red', width: 2},
                        opacity: 0.5
                    }
                ]
            };
            Plotly.relayout('cv-plot', update);
        }

        // Gráfico de niveles de energía y partículas
        const energyLevelsDiv = document.getElementById('energy-levels');
        let svg = d3.select('#energy-levels')
            .append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('preserveAspectRatio', 'xMidYMid meet');

        // Crear grupos SVG para niveles, partículas y anotaciones
        const levelsGroup = svg.append('g').attr('class', 'levels-group');
        const particlesGroup = svg.append('g').attr('class', 'particles-group');
        const annotationsGroup = svg.append('g').attr('class', 'annotations-group');

        // Escalas
        let xScale, yScale;

        // Constante para E_max a T = 0.001 K
        const E_max_T0001K = 20 * kB * 0.001;
        let E_fixed_max = null;

        // Partículas
        const num_particles = 300;
        let particles = [];

        // Variables globales
        let currentT = 0.001; // Temperatura inicial
        let updateEmaxLabel = true; // Variable para controlar la actualización del label

        function updateScales(E_max) {
            const plotWidth = energyLevelsDiv.clientWidth;
            const plotHeight = energyLevelsDiv.clientHeight;

            const marginLeft = plotMargins.l;
            const marginRight = plotMargins.r;

            const width = plotWidth;
            const height = plotHeight;

            svg.attr('viewBox', `0 0 ${width} ${height}`);

            xScale = d3.scaleLinear()
                .domain([0, 3])
                .range([marginLeft, width - marginRight]);

            // Ajustar el rango de energía
            yScale = d3.scaleLinear()
                .domain([0, E_max * 0.5])
                .range([height - 30, 30]);
        }

        function energyToColor(E, E_max) {
            const normalized_E = E / E_max;
            const r = Math.max(0, Math.min(1, 2 * normalized_E)) * 255;
            const b = Math.max(0, Math.min(1, 2 * (1 - normalized_E))) * 255;
            return `rgba(${r},0,${b},0.5)`; // Opacidad del 50%
        }

        function updateEnergyLevels() {
            const autoScale = autoScaleCheckbox.checked;
            let E_max;

            if (autoScale) {
                if (currentT < 0.001) {
                    // Para T < 0.001 K, fijamos E_max al valor de T = 0.001 K
                    E_max = E_max_T0001K;
                } else {
                    // Autoescalado activado y T >= 0.001 K
                    E_max = 20 * kB * currentT;
                }
            } else {
                // Autoescalado desactivado, usamos E_fixed_max
                E_max = E_fixed_max;
            }

            updateScales(E_max);
            drawEnergyLevels(E_max);
        }

        function drawEnergyLevels(E_max) {
            // Limpiar niveles de energía
            levelsGroup.selectAll('.energy-level').remove();

            const totalWidth = 3;
            const groupGap = 0.2; // Espacio entre grupos
            const groupWidth = (totalWidth - 2 * groupGap) / 3;

            const xPositions = [
                0,
                groupWidth + groupGap,
                2 * (groupWidth + groupGap)
            ];

            function drawLevels(En, start, max_plot) {
                for (let n = 0; n < max_plot; n++) {
                    let yPosition = yScale(En[n]);
                    if (yPosition >= 30 && yPosition <= yScale.range()[0]) {
                        levelsGroup.append('line')
                            .attr('class', 'energy-level')
                            .attr('x1', xScale(start))
                            .attr('x2', xScale(start + groupWidth))
                            .attr('y1', yPosition)
                            .attr('y2', yPosition)
                            .attr('stroke', 'gray')
                            .attr('stroke-width', 0.5);
                    }
                }
            }

            let n_trans_max_plot = En_trans.findIndex(E => E > yScale.domain()[1]);
            if (n_trans_max_plot === -1) n_trans_max_plot = En_trans.length;

            let j_rot_max_plot = En_rot.findIndex(E => E > yScale.domain()[1]);
            if (j_rot_max_plot === -1) j_rot_max_plot = En_rot.length - 1;

            let n_vib_max_plot = En_vib.findIndex(E => E > yScale.domain()[1]);
            if (n_vib_max_plot === -1) n_vib_max_plot = En_vib.length - 1;

            drawLevels(En_trans, xPositions[0], n_trans_max_plot);
            drawLevels(En_rot, xPositions[1], j_rot_max_plot + 1);
            drawLevels(En_vib, xPositions[2], n_vib_max_plot + 1);

            // Limpiar etiquetas de modos
            levelsGroup.selectAll('.label').remove();

            const labelYPosition = yScale.range()[1] - 5;

            levelsGroup.append('text')
                .attr('class', 'label')
                .attr('x', xScale(xPositions[0] + groupWidth / 2))
                .attr('y', labelYPosition)
                .attr('text-anchor', 'middle')
                .text('Traslacional (T)');

            levelsGroup.append('text')
                .attr('class', 'label')
                .attr('x', xScale(xPositions[1] + groupWidth / 2))
                .attr('y', labelYPosition)
                .attr('text-anchor', 'middle')
                .text('Rotacional (R)');

            levelsGroup.append('text')
                .attr('class', 'label')
                .attr('x', xScale(xPositions[2] + groupWidth / 2))
                .attr('y', labelYPosition)
                .attr('text-anchor', 'middle')
                .text('Vibracional (V)');

            // Limpiar etiquetas del eje Y
            levelsGroup.selectAll('.y-axis-label').remove();

            levelsGroup.append('text')
                .attr('class', 'y-axis-label')
                .attr('x', xScale(-0.2))
                .attr('y', yScale(yScale.domain()[1] / 2))
                .attr('text-anchor', 'middle')
                .attr('transform', `rotate(-90,${xScale(-0.2)},${yScale(yScale.domain()[1] / 2)})`)
                .text('Energía');

            // Agregar el label de E = k_B T
            annotationsGroup.selectAll('.e-max-label').remove();
            annotationsGroup.selectAll('.e-max-arrow').remove();

            if (updateEmaxLabel) {
                // Calcular E_label_energy = kB * currentT
                let E_label_energy = kB * currentT;

                // E_label_energy en Joules, con 2 cifras significativas en notación científica
                let E_label_energy_value = E_label_energy.toExponential(1) + 'J';

                // El valor en KBT es 1 KBT
                let E_label_energy_KBT_formatted = '= K₍B₎T';

                // Texto del label en dos líneas
                let E_label_text_line1 = E_label_energy_value;
                let E_label_text_line2 = E_label_energy_KBT_formatted;

                // Posicionar el label
                let labelX;
                let textAnchor;
                let arrowDirection; // 'left' or 'right'

                if (isMobile) {
                    labelX = xScale(3.15); // Mover al margen derecho
                    textAnchor = 'end'; // Alinear a la derecha
                    arrowDirection = 'left';
                } else {
                    labelX = xScale(-0.253); // Posición original
                    textAnchor = 'start'; // Alinear a la izquierda
                    arrowDirection = 'right';
                }

                let labelY = yScale(kB * currentT) - 9; // Ajusta la posición vertical según sea necesario

                // Agregar el texto en dos líneas con subíndice
                let textElement = annotationsGroup.append('text')
                    .attr('class', 'e-max-label')
                    .attr('x', labelX)
                    .attr('y', labelY)
                    .attr('text-anchor', textAnchor)
                    .attr('font-size', '12px')
                    .attr('font-family', 'monospace');

                textElement.append('tspan')
                    .attr('x', labelX)
                    .attr('dy', '0')
                    .text(E_label_energy_value);

                textElement.append('tspan')
                    .attr('x', labelX)
                    .attr('dy', '12') // Espacio entre líneas
                    .html(E_label_energy_KBT_formatted.replace('K₍B₎T', 'K<tspan baseline-shift="sub">B</tspan>T'));

                // Dibujar la flecha pequeña
                let arrowX, arrowY;
                let arrowLength = 14; // Longitud de la flecha
                let arrowOffset = 35; // Offset desde el texto

                arrowY = labelY + 9;  // Centrar verticalmente entre las dos líneas

                if (arrowDirection === 'right') {
                    arrowX = labelX + arrowOffset; // Flecha hacia la derecha
                    annotationsGroup.append('line')
                        .attr('class', 'e-max-arrow')
                        .attr('x1', arrowX)
                        .attr('y1', arrowY)
                        .attr('x2', arrowX + 0)
                        .attr('y2', arrowY)
                        .attr('stroke', 'black')
                        .attr('stroke-width', 0.5);

                    annotationsGroup.append('polygon')
                        .attr('class', 'e-max-arrow')
                        .attr('points', `${arrowX + 5},${arrowY - 3} ${arrowX + 5},${arrowY + 3} ${arrowX + 14},${arrowY}`)
                        .attr('fill', 'gray');
                } else if (arrowDirection === 'left') {
                    arrowX = labelX - arrowOffset; // Flecha hacia la izquierda
                    annotationsGroup.append('line')
                        .attr('class', 'e-max-arrow')
                        .attr('x1', arrowX)
                        .attr('y1', arrowY)
                        .attr('x2', arrowX - 0)
                        .attr('y2', arrowY)
                        .attr('stroke', 'black')
                        .attr('stroke-width', 0.5);

                    annotationsGroup.append('polygon')
                        .attr('class', 'e-max-arrow')
                        .attr('points', `${arrowX - 5},${arrowY - 3} ${arrowX - 5},${arrowY + 3} ${arrowX - 14},${arrowY}`)
                        .attr('fill', 'gray');
                }

                // Asegurar que las anotaciones estén por encima de las partículas
                annotationsGroup.raise();
            }

            // Añadir la línea horizontal roja
            svg.selectAll('.kbt-line').remove();

            // Calcular las posiciones x de inicio y fin
            let lineLeftX = xScale(xPositions[0]); // Borde izquierdo de niveles traslacionales
            let lineRightX = xScale(xPositions[2] + groupWidth); // Borde derecho de niveles vibracionales

            // Dibujar la línea horizontal roja
            svg.append('line')
                .attr('class', 'kbt-line')
                .attr('x1', lineLeftX)
                .attr('y1', yScale(kB * currentT))
                .attr('x2', lineRightX)
                .attr('y2', yScale(kB * currentT))
                .attr('stroke', 'red')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.5);
        }

        function updateParticles(T) {
            const beta = 1 / (kB * T);

            // Cálculo de probabilidades
            // Translacional
            let minE_trans = En_trans[0];
            let shifted_E_trans = En_trans.map(E => E - minE_trans);
            let exp_factor_trans = shifted_E_trans.map(E => Math.exp(-beta * E));
            let Z_trans = exp_factor_trans.reduce((a, b) => a + b, 0);
            let P_trans = exp_factor_trans.map(p => p / Z_trans);

            // Rotacional
            let J = [...Array(j_rot_max + 1).keys()];
            let degeneracy_rot = J.map(J_value => 2 * J_value + 1);
            let minE_rot = En_rot[0];
            let shifted_E_rot = En_rot.map(E => E - minE_rot);
            let exp_factor_rot = shifted_E_rot.map((E, index) => degeneracy_rot[index] * Math.exp(-beta * E));
            let Z_rot = exp_factor_rot.reduce((a, b) => a + b, 0);
            let P_rot = exp_factor_rot.map(p => p / Z_rot);

            // Vibracional
            let minE_vib = En_vib[0];
            let shifted_E_vib = En_vib.map(E => E - minE_vib);
            let exp_factor_vib = shifted_E_vib.map(E => Math.exp(-beta * E));
            let Z_vib = exp_factor_vib.reduce((a, b) => a + b, 0);
            let P_vib = exp_factor_vib.map(p => p / Z_vib);

            // Limpiar partículas existentes
            particlesGroup.selectAll('.particle').remove();
            particles = [];

            const totalWidth = 3;
            const groupGap = 0.2;
            const groupWidth = (totalWidth - 2 * groupGap) / 3;

            const xPositions = [
                0,
                groupWidth + groupGap,
                2 * (groupWidth + groupGap)
            ];

            const particles_trans = Math.round(num_particles / 3);
            const particles_rot = Math.round(num_particles / 3);
            const particles_vib = num_particles - particles_trans - particles_rot;

            function addParticles(P, En, xStart, num) {
                for (let i = 0; i < num; i++) {
                    let level = weightedRandom(P);
                    let energy = En[level];
                    let yPosition = yScale(energy);
                    if (yPosition >= 30 && yPosition <= yScale.range()[0]) {
                        let x = xScale(xStart + Math.random() * groupWidth);
                        let y = yPosition;
                        let color = energyToColor(energy - En[0], yScale.domain()[1]);

                        let particle = particlesGroup.append('circle')
                            .attr('class', 'particle')
                            .attr('cx', x)
                            .attr('cy', y)
                            .attr('r', 4)
                            .attr('fill', color);
                        particles.push(particle);
                    }
                }
            }

            addParticles(P_trans, En_trans, xPositions[0], particles_trans);
            addParticles(P_rot, En_rot, xPositions[1], particles_rot);
            addParticles(P_vib, En_vib, xPositions[2], particles_vib);
        }

        function weightedRandom(prob) {
            let sum = 0;
            let r = Math.random();
            for (let i = 0; i < prob.length; i++) {
                sum += prob[i];
                if (r <= sum) {
                    return i;
                }
            }
            return prob.length - 1;
        }

        // Controladores
        const tempSlider = document.getElementById('temp-slider');
        const tempValue = document.getElementById('temp-value');
        const autoScaleCheckbox = document.getElementById('auto-scale-checkbox');

        function updateTemperature() {
            const logT = parseFloat(tempSlider.value);
            const T = Math.pow(10, logT);
            tempValue.textContent = `T = ${
    T < 0.1 ? T.toFixed(3) : T < 1 ? T.toFixed(2) : T < 10 ? T.toFixed(1) : T < 100 ? T.toFixed(1) : Math.round(T)
} K`;


            // Forzar reflow
            void tempValue.offsetWidth;

            currentT = T;
            updateEmaxLabel = true;
            updateEnergyLevels();
            updateParticles(T);
            updateTempLine(T);
        }

        function updateAutoScale() {
            const autoScale = autoScaleCheckbox.checked;

            if (!autoScale) {
                // Capturar E_max actual como E_fixed_max
                if (currentT < 0.001) {
                    E_fixed_max = E_max_T0001K;
                } else {
                    E_fixed_max = 20 * kB * currentT;
                }
                updateEnergyLevels(); // Actualizar escalas y niveles de energía
            } else {
                E_fixed_max = null; // Restablecer
                updateEmaxLabel = true; // Actualizar el label al activar autoescalado
                updateEnergyLevels(); // Actualizar escalas y niveles de energía
                updateParticles(currentT); // Redistribuir partículas al activar autoescalado
            }

            // Actualizar el color de fondo del checkbox
            autoScaleCheckbox.style.backgroundColor = autoScale ? '#4CAF50' : 'transparent';
        }

        tempSlider.addEventListener('input', updateTemperature);
        autoScaleCheckbox.addEventListener('change', updateAutoScale);

        // Manejar redimensionamiento de ventana
        window.addEventListener('resize', () => {
            // Actualizar la detección de dispositivo móvil
            isMobile = window.matchMedia("(max-width: 600px)").matches;
            annotationFontSize = isMobile ? 10 : 12;

            // Actualizar los márgenes del gráfico
            plotMargins = isMobile ? { t: 5, l: 60, r: 20, b: 50 } : { t: 30, l: 60, r: 20, b: 50 };

            // Actualizar las anotaciones
            layoutCv.annotations = getAnnotations();

            // Actualizar el tamaño de fuente de las anotaciones
            layoutCv.annotations.forEach(annotation => {
                annotation.font.size = annotationFontSize;
            });

            // Actualizar el layout del gráfico
            layoutCv.margin = plotMargins;

            // Actualizar el gráfico
            Plotly.relayout('cv-plot', layoutCv);
            Plotly.Plots.resize('cv-plot');
            updateEnergyLevels(); // Actualizar escalas y niveles de energía
        });

        // Inicializar
        updateTemperature();
        updateAutoScale();

        // Función para dibujar los niveles de energía inicialmente
        function initializeEnergyLevels() {
            updateEnergyLevels();
            updateParticles(currentT);
        }

        // Llamar a la función de inicialización después de cargar todo
        initializeEnergyLevels();
    </script>
</body>
</html>
